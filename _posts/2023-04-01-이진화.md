<img src="./lecture_image/00_title.png">

<table border=1 width=100%>
    <tr><td style="border: 1px solid black; width:600px; height:40px; text-align: center;"><font size=4 color=blue><b>[2차시] 학습목표</b></font></td></tr>       
    <tr><td style="border: 1px solid black; text-align: left;"><font size=3>○ 칼라 이미지를 gray 이미지로 변환하는 방법을 학습한다.<br>
○ gray 이미지를 binary 이미지로 변환하는 방법을 학습한다.
        </font></td></tr>   
</table>

# Gray와 Binary 이미지 

- 시각은 색상정보에 대해 잘못된 정보를 보내주는 경우가 많음
  - 밤에 색상을 볼때 정확한 색상을 보여주지 못함 - 명도 (검정색이 섞이는 것)
  - 색상에 빛을 강하게 비추는 경우 정확한 색상을 보여주지 못함 - 채도 (흰색이 섞이는 것)
- 칼라는 너무 많은 정보를 가지고 있기때문에 연산량이 많음
  - 실시간 처리가 어려움
  - 따라서 gray 이미지나 binary 이미지로 변환해서 처리하는 것이 일반적
<br><br>  
- gray 이미지 : 0-255로 된 픽섹로만 구성된 흑백이미지
- binary(이진) 이미지 : 0(검정색)과 255(흰색)으로만 구성된 이미지 (마스크 패턴, 필터링)

<img src="./lecture_image/02_gray_binary.png" width=50%>


- 칼라 → gray 이미지 변환 방법 2가지
  - imread()로 이미지를 읽을 때 변환해서 읽는 방법
    -  img = cv2.imread(파일명, <font color=red>cv2.IMREAD_GRAYSCALE</font>)
  - 칼라 이미지로 읽어서 cvtColor() 변환하는 방법 → 칼라 이미지가 필요한 경우 (출력)
    -  img_gray = cv2.cvtColor(이미지객체, <font color=red>cv2.COLOR_BGR2GRAY</font>)
<br><br>    
- matplotlib 라이브러리의 colormap
  - 기본값 :  viridis
  
  <img src="./lecture_image/02_colormap.png" width=70%>

## gray 이미지  만들기

### imread()를 사용해서 gray 이미지로 변환해서 읽는 방법 


```python
import cv2
import matplotlib.pyplot as plt
```


```python
# 실습
img = cv2.imread("cats.jpg",cv2.IMREAD_GRAYSCALE)

plt.xticks([])
plt.yticks([])
plt.imshow(img, cmap="gray")
plt.show()
```


    
![png](output_5_0.png)
    


### 칼라이미지로 읽어서 gray 이미지로 변환하는 방법


```python
# 실습
img = cv2.imread("cats.jpg",cv2.IMREAD_COLOR)

# 컬러를 GRAY로 변환
grayimg = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

plt.xticks([])
plt.yticks([])
plt.imshow(grayimg, cmap="gray")
plt.show()
```


    
![png](output_7_0.png)
    


## 이진 (Binary) 이미지 만들기

- 이진 이미지는 픽셀값이 0과 1(255)로만 구성
- 이진 이미지의 필요 : 배경과 객체의 구분, 관심영역과 비관심 영역의 구분, 마스크 생성 등


- <font color=red>_, thr = cv2.threshold(img, threshold_value, value, flag)</font>
  - img : Grayscale 이미지
  - threshold_value : 픽셀 문턱값 (0과 1로 나누기 위한 기준값)
  - value : 문턱값보다 클 때 적용되는 값
  - flag : 문턱값 적용 방법
  


- flag : 문턱값 적용 방법
  - cv2.THRESH_BINARY : 픽셀값이 문턱값보다 크면 value, 아니면 0을 할당
  - cv2.THRESH_BINARY_INV : 픽셀값이 문턱값보다 크면 0, 아니면 value를 할당
  - cv2.THRESH_TRUNC : 픽셀값이 문턱값보다 크면 문턱값, 아니면 픽셀값을 그대로 할당
  - cv2.THRESH_TOZERO : 픽셀값이 문턱값보다 크면 픽셀값, 아니면 0을 할당
  - cv2.THRESH_TOZERO_INV : 픽셀값이 문턱값보다 크면 0, 아니면 픽셀값을 할당


```python
# 실습
img = cv2.imread("cats.jpg", cv2.IMREAD_GRAYSCALE)

# 이진화(흑백 이미지, 기준값, 기준이 넘으면 적용될 값, 적용시킬 방법)
#  0 : 검정색, 255 : 흰색
_, thr1 = cv2.threshold(img,150,255, cv2.THRESH_BINARY_INV)

plt.imshow(thr1,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.show()
```


    
![png](output_9_0.png)
    



```python
# 실습
img = cv2.imread("cats.jpg", cv2.IMREAD_GRAYSCALE)

plt.figure(figsize=(8,8))
plt.subplot(2,2,1)
_, thr1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY_INV)
plt.imshow(thr1, cmap="gray")
plt.title("THRESH_BINARY_INV")
plt.xticks([])
plt.yticks([])

plt.subplot(2,2,2)
_, thr2 = cv2.threshold(img,127,255,cv2.THRESH_TRUNC)
plt.imshow(thr2, cmap="gray")
plt.title("THRESH_TRUNC")
plt.xticks([])
plt.yticks([])

plt.subplot(2,2,3)
_, thr3 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO)
plt.imshow(thr3, cmap="gray")
plt.title("THRESH_TOZERO")
plt.xticks([])
plt.yticks([])

plt.subplot(2,2,4)
_, thr4 = cv2.threshold(img,127,255,cv2.THRESH_TOZERO_INV)
plt.imshow(thr4, cmap="gray")
plt.title("THRESH_TOZERO_INV")
plt.xticks([])
plt.yticks([])
```




    ([], [])




    
![png](output_10_1.png)
    


# 실습
img = cv2.imread("cats.jpg", cv2.IMREAD_GRAYSCALE)

# 이진화(흑백 이미지, 기준값, 기준이 넘으면 적용될 값, 적용시킬 방법)
#  0 : 검정색, 255 : 흰색
_, thr1 = cv2.threshold(img,150,255, cv2.THRESH_BINARY_INV)

plt.imshow(thr1,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.show()

<table border=1 width=100%>
    <tr><td style="border: 1px solid black; width:600px; text-align: left;"><font size=4 color=red><b>실습문제</b></font><br><br>
        <font size=4>○ threshold() 함수를 이용하여 다른 이미지를 아래와 같이 변환해보자.</font></td></tr>       
    <tr><td style="border: 1px solid black; text-align: left;">
        <img src="./lecture_image/02_threshold.PNG" width=70%></td></tr>   
</table>

### 임계값 결정하기 1 : OTSU 알고리즘

- 이진 이미지를 만들때 가장 중요한 요소 : 임계값 설정
- OTSU의 이진화 알고리즘
  - 임계값을 임의로 정하고 픽셀을 두 분류로 나눔
  - 두 분류의 명암 분포를 구하는 작업을 반복
  - 두 분류의 명암 분포가 가장 균일할 때의 임계값을 선택
- OTSU의 이진화 알고리즘 적용하기
  - 임계값을 -1로하고 옵션을 THRESH_OTSU로 설정하여 이진화
- 단점 : 모든 경우의 수를 조사해야 하므로 속도가 느림


```python
# 실습
img = cv2.imread("./lecture_image/news_paper.jpg", cv2.IMREAD_GRAYSCALE)
_, thr1 = cv2.threshold(img,127,255, cv2.THRESH_BINARY)

plt.subplot(1,2,1)
plt.imshow(thr1,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("binary")

# otus 알고리즘 적용 이미지
t, thr2 = cv2.threshold(img,-1,255,cv2.THRESH_BINARY | cv2.THRESH_OTSU)
plt.subplot(1,2,2)
plt.imshow(thr2,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("otsu_%d"%t)
```




    Text(0.5, 1.0, 'otsu_154')




    
![png](output_14_1.png)
    


### 임계값 결정하기 2 : 적응형 thresholding

- 전체 이미지를 이용하면 일정하지 않는 조명, 배경색이 여러개인 경우 하나의 임계값으로 선명한 이진 이미지를 만들기 어려움
- 적응형 thresholding
  - 이미지를 여러 영역으로 나눔
  - 해당 영역의 픽셀 값만 활용하여 임계값을 계산
  - 각 영역별로 이진화를 진행
  
   <img src="./lecture_image/02_adaptive_threshold.PNG" width=30%></td></tr> 

<br>

- <font color=red>cv2.adaptiveThreshold(img, value, method, type_flag, block_size, C)</font>
  - img : 입력영상
  - value : 임계값을 만족하는 픽셀에 적용할 값
  - method : 임계값 결정 방법
  - cv2.ADAPTIVE_THRESH_MEAN_C : 이웃 픽셀의 평균으로 결정
  - cv2.ADAPTIVE_THRESH_GAUSSIAN_C : 가우시안 분포에 따른 가중치의 합으로 결정
  - type_flag : 스레시홀딩 적용 방법 (cv2.threshod()와 동일)
  - block_size : 영역으로 나눌 블록의 크기(n x n), 홀수
  - C : 계산된 임계값 결과에서 가감할 상수(음수 가능)


```python
# 실습
img = cv2.imread("sudoku.png", cv2.IMREAD_GRAYSCALE)

plt.figure(figsize=(8,8))
plt.subplot(2,2,1)
plt.imshow(img,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("original")

# otus 알고리즘 적용 이미지
t, thr1 = cv2.threshold(img,-1,255,cv2.THRESH_BINARY | cv2.THRESH_OTSU)
plt.subplot(2,2,2)
plt.imshow(thr1,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("otsu_%d"%t)

thr2 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_MEAN_C,
                            cv2.THRESH_BINARY,9,5)
plt.subplot(2,2,3)
plt.imshow(thr2,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("ADAPTIVE_THRESH_MEAN_C")

thr2 = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY,9,5)
plt.subplot(2,2,4)
plt.imshow(thr2,cmap="gray")
plt.xticks([])
plt.yticks([])
plt.title("ADAPTIVE_THRESH_GAUSSIAN_C")
```




    Text(0.5, 1.0, 'ADAPTIVE_THRESH_GAUSSIAN_C')




    
![png](output_16_1.png)
    


- 실행 결과
  - THRESH_OTSU : 분류가 잘 되지 않음
  - ADAPTIVE_THRESH_MEAN_C : 선명하지만 잡음이 많음
  - ADAPTIVE_THRESH_GAUSSIAN_C : 잡음은 적지만 선명도가 떨어짐

<table border=1 width=100%>
    <tr><td style="border: 1px solid black; width:600px; text-align: left;"><font size=4 color=red><b>실습문제</b></font><br><br>
        <font size=4>○ 다른 이미지를 아래와 같이 이진이미지로 변환해보자.</font></td></tr>       
    <tr><td style="border: 1px solid black; text-align: left;">
        <img src="./lecture_image/02_threshold2.png" width=70%></td></tr>   
</table>

<table border=1 width=100%>
    <tr><td style="border: 1px solid black; width:600px; height:40px; text-align: center;"><font size=4 color=blue><b>[2차시] 학습요약</b></font></td></tr>       
    <tr><td style="border: 1px solid black; text-align: left;"><font size=3>
        
○ 칼라이미지를 gray 이미지로 변환하는 방법 
  - imread() 함수로 직접 변환하는 방법 
  - 칼라이미지로 읽은 후에 cvtColor() 함수로 변환하는 방법 

○ gray 이미지를 binary로 변환하는 방법 
  - threshold() 함수를 사용하는 방법  
  - OTSU 이진화 알고리즘을 사용하는 방법
  - adaptiveThreshold() 함수를 사용하는 방법
        
</font></td></tr>   
</table>
